var documenterSearchIndex = {"docs":
[{"location":"non_equilibrium/#Kintetic-Monte-Carlo","page":"Non-Equilibrium Tools","title":"Kintetic Monte-Carlo","text":"","category":"section"},{"location":"non_equilibrium/","page":"Non-Equilibrium Tools","title":"Non-Equilibrium Tools","text":"next\nnext_time\nnext_event\nadvance!","category":"page"},{"location":"non_equilibrium/#MonteCarloX.next","page":"Non-Equilibrium Tools","title":"MonteCarloX.next","text":"next([rng::AbstractRNG,] alg::KineticMonteCarlo, rates::AbstractWeights)::Tuple{Float64,Int}\n\nNext stochastic event (Delta t, index) drawn proportional to probability given in rates\n\n\n\n\n\nnext([rng::AbstractRNG,] alg::KineticMonteCarlo, event_handler::AbstractEventHandlerRate)\n\nNext stochastic event (Delta t, event type) organized by event_handler fast(to be tested, depends on overhead of EventList) implementation of nexteventrate if defined by EventList object\n\n\n\n\n\nGenerate a new event from a collection of inhomogeneous poisson processes with rates Lambda(t).\n\nArguments\n\nrates: rates(dt); Float -> [Float]\nmax_rate: maximal rate in near future (has to be evaluated externally)\nrng: random number generator\n\nAPI - output\n\nreturns the next event time and event id as tuple (dt, id)\n\n\n\n\n\n","category":"function"},{"location":"non_equilibrium/#MonteCarloX.next_time","page":"Non-Equilibrium Tools","title":"MonteCarloX.next_time","text":"next_time([rng::AbstractRNG,] rate::Float64)::Float64\n\nNext stochastic Delta t for Poisson process with rate\n\n\n\n\n\nnexteventtime(rate::Function, max_rate::Float64, rng::AbstractRNG)::Float64\n\nGenerate a new event from an inhomogeneous poisson process with rate Lambda(t). Based on (Ogata’s Modified Thinning Algorithm: Ogata,  1981,  p.25,  Algorithm  2) see also https://www.math.fsu.edu/~ychen/research/Thinning%20algorithm.pdf\n\nArguments\n\nrate: rate(dt) has to be defined outside (e..g t-> rate(t+t0,args))\nmax_rate: maximal rate in near future (has to be evaluated externally)\nrng: random number generator\n\nAPI - output\n\nreturns the next event time\n\n\n\n\n\nGenerate a new event from an inhomogeneous poisson process with rate Lambda(t) under the assumption that rate(dt) is monotonically decreasing. Based on (Ogata’s Modified Thinning Algorithm: Ogata,  1981,  p.25,  Algorithm  3) see also https://www.math.fsu.edu/~ychen/research/Thinning%20algorithm.pdf\n\nArguments\n\nrate: rate(dt) has to be defined outside (e..g t-> rate(t+t0,args))\nrng: random number generator\n\nAPI - output\n\nreturns the next event time\n\n\n\n\n\n","category":"function"},{"location":"non_equilibrium/#MonteCarloX.next_event","page":"Non-Equilibrium Tools","title":"MonteCarloX.next_event","text":"next_event([rng::AbstractRNG,] rates::AbstractWeights)::Int\n\nSelect a single random index in 1:length(rates) with probability proportional to the entry in rates.\n\nRemarks\n\nThis is on average twice as fast as StatsBase.sampling because it can iterate from either beginning or end of rates\n\n\n\n\n\nnext_event([rng::AbstractRNG,] event_handler::AbstractEventHandlerRate{T})::T where T\n\nSelect a single random event with a given probability managed by event_handler.\n\nThe event_handler also manages the case that no valid events are left (e.g. when all rates are equal to zero). This becomes relevant when using advance! to advance for some time.\n\nSee also: advance!\n\n\n\n\n\nGenerate a new event id from a collection of inhomogeneous poisson processes with rates Lambda(t).\n\nArguments\n\nrates: rates(dt); Float -> [Float]\nmax_rate: maximal rate in near future (has to be evaluated externally)\nrng: random number generator\n\nAPI - output\n\nreturns the next event id\n\n\n\n\n\n","category":"function"},{"location":"non_equilibrium/#MonteCarloX.advance!","page":"Non-Equilibrium Tools","title":"MonteCarloX.advance!","text":"advance!([rng::AbstractRNG], alg::KineticMonteCarlo, event_handler::AbstractEventHandlerRate, update!::Function, total_time::T)::T where {T<:Real}\n\nDraw events from event_handler and update event_handler with update! until total_time has passed. Return time of last event.\n\n\n\n\n\nadvance!([rng::AbstractRNG], alg::KineticMonteCarlo, rates::AbstractVector, update!::Function, total_time::T)::T where {T<:Real}\n\nDraw events from event_handler and update event_handler with update! until total_time has passed. Return time of last event.\n\n\n\n\n\n","category":"function"},{"location":"non_equilibrium/#Inhomogeneous-Poisson-Process","page":"Non-Equilibrium Tools","title":"Inhomogeneous Poisson Process","text":"","category":"section"},{"location":"non_equilibrium/","page":"Non-Equilibrium Tools","title":"Non-Equilibrium Tools","text":"","category":"page"},{"location":"equilibrium/#Importance-Sampling-(Metropolis)","page":"Equilibrium Tools","title":"Importance Sampling (Metropolis)","text":"","category":"section"},{"location":"equilibrium/","page":"Equilibrium Tools","title":"Equilibrium Tools","text":"accept\nsweep","category":"page"},{"location":"equilibrium/#MonteCarloX.accept","page":"Equilibrium Tools","title":"MonteCarloX.accept","text":"accept(log_weight::Function, args_new::Tuple{Number, N}, args_old::Tuple{Number, N}, rng::AbstractRNG)::Bool where N\n\nEvaluate most general acceptance probability for imporance sampling of P(x) propto e^mathrmlog_weight(x).\n\nArguments\n\nlog_weight(args): logarithmic ensemble weight function, e.g., canomical ensemble mathrmlog_weight(x) = -beta x\nargs_new: arguments (can be Number or Tuple) for new (proposed) state\nargs_old: arguments (can be Number or Tuple) for old                        state\nrng: random number generator, e.g. MersenneTwister\n\nSpecializations\n\naccept(alg::Metropolis(), rng::AbstractRNG, xnew::T, xold::T) where T (@ref)\n\n\n\n\n\naccept(alg::Metropolis, rng::AbstractRNG, beta::Float64, dx::T)::Bool where T\n\nStandard metropolis algorithm with p(xto x^prime) = mathrmmin (1 e^-beta Delta x ) where Delta x = x^prime - x\n\n\n\n\n\naccept(alg::MetropolisHastings, rng::AbstractRNG, beta::Float64, dx::T, q_old::Float64, q_new::Float64)::Bool where T\n\n\n\n\n\n","category":"function"},{"location":"equilibrium/#MonteCarloX.sweep","page":"Equilibrium Tools","title":"MonteCarloX.sweep","text":"sweep(list_updates, list_weights::AbstractWeights, rng::AbstractRNG; number_updates::Int=1) where T<:AbstractFloat\n\nRandomly pick und run update (has to check acceptance by itself!) from list_updates with probability specified in list_probabilities and repeat this number_updates times.\n\nRemarks\n\nWalker's alias method?\n\n\n\n\n\n","category":"function"},{"location":"equilibrium/#Reweighting","page":"Equilibrium Tools","title":"Reweighting","text":"","category":"section"},{"location":"equilibrium/","page":"Equilibrium Tools","title":"Equilibrium Tools","text":"expectation_value_from_timeseries\ndistribution_from_timeseries","category":"page"},{"location":"equilibrium/#MonteCarloX.expectation_value_from_timeseries","page":"Equilibrium Tools","title":"MonteCarloX.expectation_value_from_timeseries","text":"expectation_value_from_timeseries(log_P_target::Function, log_P_source::Function, list_args, list_obs::Vector{Tin})::Tout where {Tin<:Number,Tout<:AbstractFloat}\n\nCalculate the expectation value of an observable in P_target from a list of measured observables in P_source.\n\nThis can be used for observables measured in equilibrium, e.g., from methods:\n\nmetropolis         (for each temperature separate)\nparallel tempering (for each temperature separate)\nmulticanonical\npopulation annealing\n\nBackground\n\nDefinition of reweighting in general:\n\nlangle Orangle = sum O_i P_mathrmtarget(args_i)P_mathrmsource(args_i)  sum P_mathrmtarget(args_i)P_mathrmsource(args_i)\n\nDefinition of reweighting for the canonical ensemble:\n\nlangle Orangle = sum O_i e^beta_mathrmtarget E_i - beta_mathrmsource E_i  sum e^beta_mathrmtarget E_i - beta_mathrmsource E_i\n\nRemark\n\nSo far, this may not be well implemented for type stability. However, it should not be the most timeconsuming part of the simulation so this problem is moved to later time.\n\n\n\n\n\n","category":"function"},{"location":"equilibrium/#MonteCarloX.distribution_from_timeseries","page":"Equilibrium Tools","title":"MonteCarloX.distribution_from_timeseries","text":"distribution_from_timeseries(log_P_target, log_P_source, list_args, range [, mode])\n\nestimate reweighted distribution over range for target weights log_P_target from a timeseries list_args that was measured with log_P_source. Intended also for n-dimensional probability distributions, e.g. P(E,M), where list_args needs to be a list of tuples\n\nreturns:     - StatsBase.Histogram\n\n\n\n\n\n","category":"function"},{"location":"","page":"Getting Started","title":"Getting Started","text":"DocTestSetup = quote\n    using MonteCarloX\nend","category":"page"},{"location":"#MonteCarloX.jl","page":"Getting Started","title":"MonteCarloX.jl","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"MonteCarloX.jl is an open-source julia framework for basic and advanced Monte-Carlo simulations of equilibrium and non-equilibrium problems. The basci functionality is developed with physics problems in mind but is intended to generalize beyond, e.g., for chemical reactions etc.","category":"page"},{"location":"#Goal","page":"Getting Started","title":"Goal","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Since Monte-Carlo algorithms are often tailored to specific problems, we here attempt to break them down into small basic functions that can be applied independent of the unterlying models. We thereby separate the algorithmic part from the model part. MonteCarloX will only contain the core algorithmic part and requires additional classes or even packages for models that will build on MonteCarloX. Examples of how these could be designed are collected under examples. Different to other simulation packages, the goal of MonteCarloX is not to hide the final simulation under simple black-box function calls, but to foster the construction of clean template simulations that apply an algorithm where the model can be easily replaced.","category":"page"},{"location":"#Contribute","page":"Getting Started","title":"Contribute","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"MonteCarloX employs continuous integration with unit tests for all functions. This is complicated by the stochastic nature of Monte Carlo simulations, which we include by formulating analytical problems and conducting statistical tests. Right now, we are in the process of developing a stable base that fits the needs of a variety of advanced algorithms but API can still change severely. Once we have a first stable verions, MonteCarloX is intendend as a community project.","category":"page"},{"location":"helper/#Helper-Tools","page":"Helper","title":"Helper Tools","text":"","category":"section"},{"location":"helper/","page":"Helper","title":"Helper","text":"Order = [:type, :function]\nPages = [\"helper.md\"]","category":"page"},{"location":"helper/#Full-Docs","page":"Helper","title":"Full Docs","text":"","category":"section"},{"location":"helper/","page":"Helper","title":"Helper","text":"Modules = [MonteCarloX]\nPages   = [\n    \"utils.jl\",\n]\nPrivate = false","category":"page"},{"location":"helper/#MonteCarloX.binary_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T<:Real","page":"Helper","title":"MonteCarloX.binary_search","text":"binary_search(sorted::AbstractVector{T}, value::T)::Int where {T<:Real}\n\nPerfom a binary search to return the index i of an sorted array such that sorted[i-1] < value <= sorted[i]\n\nExamples\n\njulia> MonteCarloX.binary_search([1.,2.,3.,4.],2.5)\n3\n\njulia> MonteCarloX.binary_search([1,2,3,4],2)\n2\n\n\n\n\n\n","category":"method"},{"location":"helper/#MonteCarloX.log_sum-Tuple{Number, Number}","page":"Helper","title":"MonteCarloX.log_sum","text":"log_sum(a::T,b::T)\n\nReturn result of logarithmic sum c = ln(A+B) = a + ln(1+e^b-a) where C = e^c = A+B = e^a + e^b.\n\nThis is useful for sums that involve elements that span multiple orders of magnitude, e.g., the partition sum that is required as normalization factor during reweighting.\n\nExamples\n\njulia> exp(MonteCarloX.log_sum(log(2.), log(3.)))\n5.000000000000001\n\n\n\n\n\n\n","category":"method"},{"location":"helper/#MonteCarloX.random_element-Tuple{Random.AbstractRNG, Vector{Float64}}","page":"Helper","title":"MonteCarloX.random_element","text":"random_element(rng::AbstractRNG, list_probabilities::Vector{T})::Int where T<:AbstractFloat\n\nPick an index with probability defined by list_probability (which needs to be normalized).\n\n#Remark Deprecated for use of StatsBase.sample\n\nExamples\n\njulia> using Random\n\njulia> rng = MersenneTwister(1000);\n\njulia> MonteCarloX.random_element(rng, [0.1,0.2,0.3,0.4])\n4\njulia> MonteCarloX.random_element(rng, [0.1,0.2,0.3,0.4])\n4\njulia> MonteCarloX.random_element(rng, [0.1,0.2,0.3,0.4])\n3\njulia> MonteCarloX.random_element(rng, [0.1,0.2,0.3,0.4])\n4\n\n\n\n\n\n","category":"method"},{"location":"helper/#StatsBase.kldivergence-Tuple{StatsBase.Histogram, Function}","page":"Helper","title":"StatsBase.kldivergence","text":"kldivergence(P::Histogram, Q::Function)\n\nKullback-Leibler divergence between an empirical distribution (measured) and a reference distribution (analytic)\n\nSo far this is defined only for 1-dimensional distributions of type StatsBase.Histogram\n\n\n\n\n\n","category":"method"}]
}
