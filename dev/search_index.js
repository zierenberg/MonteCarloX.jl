var documenterSearchIndex = {"docs":
[{"location":"#MonteCarloX.jl-Documentation-1","page":"Home","title":"MonteCarloX.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Equilibrium-Tools-1","page":"Home","title":"Equilibrium Tools","text":"","category":"section"},{"location":"#Importance-Sampling-(Metropolis)-1","page":"Home","title":"Importance Sampling (Metropolis)","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Modules = [Metropolis]","category":"page"},{"location":"#MonteCarloX.Metropolis.accept-Union{Tuple{N}, Tuple{Function,Tuple{Number,N},Tuple{Number,N},Random.AbstractRNG}} where N","page":"Home","title":"MonteCarloX.Metropolis.accept","text":"accept(log_weight::Function, args_new::Tuple{Number, N}, args_old::Tuple{Number, N}, rng::AbstractRNG)::Bool where N\n\nEvaluate acceptance probability according to Metropolis criterium for imporance sampling of P(E) propto e^log_weight(E).\n\nArguments\n\nlog_weight(args): logarithmic ensemble weight function, e.g., canomical ensemble log_weight(E) = -beta E\nargs_new: arguments (can be Number or Tuple) for new (proposed) state\nargs_old: arguments (can be Number or Tuple) for old            state\nrng: random number generator, e.g. MersenneTwister\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Metropolis.random_element-Union{Tuple{T}, Tuple{Array{T,1},Random.AbstractRNG}} where T<:AbstractFloat","page":"Home","title":"MonteCarloX.Metropolis.random_element","text":"random_element(list_probabilities::Vector{Float64},rng::AbstractRNG)::Int\n\nPick an index from a list of probabilities.\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Metropolis.sweep-Union{Tuple{T}, Tuple{Any,Array{T,1},Random.AbstractRNG}} where T<:AbstractFloat","page":"Home","title":"MonteCarloX.Metropolis.sweep","text":"sweep(list_updates, list_probabilities::Vector{AbstractFloat}, rng::AbstractRNG; number_updates::Int=1)\n\nRandomly pick und run update (has to check acceptance by itself!) from list_updates with probability specified in list_probabilities and repeat this number_updates times.\n\n\n\n\n\n","category":"method"},{"location":"#Reweighting-1","page":"Home","title":"Reweighting","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Modules = [Reweighting]","category":"page"},{"location":"#MonteCarloX.Reweighting","page":"Home","title":"MonteCarloX.Reweighting","text":"MonteCarloX.Reweighting\n\nModule for timeseries and histogram reweighting\n\n\n\n\n\n","category":"module"},{"location":"#MonteCarloX.Reweighting.binary_search-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T<:Real","page":"Home","title":"MonteCarloX.Reweighting.binary_search","text":"binary_search(sorted::AbstractVector{T}, value::T)::Int where {T<:Real}\n\nPerfom a binary search to return the index i of an sorted array such that sorted[i-1] < value <= sorted[i]\n\nExamples\n\njulia> MonteCarloX.binary_search([1.,2.,3.,4.],2.5)\n3\n\njulia> MonteCarloX.binary_search([1,2,3,4],2)\n2\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Reweighting.canonical_timeseries-NTuple{4,Any}","page":"Home","title":"MonteCarloX.Reweighting.canonical_timeseries","text":"timeseries reweighting in canonical ensemble\n\nmethods:\n\nmetropolis         (for each temperature separate)\n\n<O> = sum Oi Ptarget(Ei)/Psource(Ei) / sum Ptarget(Ei)/Psource(args_i)\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Reweighting.distribution_from_timeseries_log-Tuple{Any,Any,Any}","page":"Home","title":"MonteCarloX.Reweighting.distribution_from_timeseries_log","text":"Estimate distribution from a list of (measured) arguments to an (n-dimensional) probability distribution\n\nFor higher dimensional distributions (e.g. P(E,M)) list_args needs to be a list of tuples\n\nreturns:\n\nDictionary\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Reweighting.expectation_value_from_histogram_log-Tuple{Function,Function,Function,Dict}","page":"Home","title":"MonteCarloX.Reweighting.expectation_value_from_histogram_log","text":"Estimate expectation value from histogram (\n\nRef: Janke\n\nTodo: rename logP... to logweight!!\n\nimportant: histobs(args) = sum Oi delta(args - args_i) hists are dictionaries? can this be generalized to higher dimensions? nd histograms as dictionary?\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Reweighting.expectation_value_from_timeseries-NTuple{4,Any}","page":"Home","title":"MonteCarloX.Reweighting.expectation_value_from_timeseries","text":"timeseries reweighting \n\nwrapper for timeseries rewighting with logarithmic distributions\n\n#Arguments\n\n\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Reweighting.expectation_value_from_timeseries_log-NTuple{4,Any}","page":"Home","title":"MonteCarloX.Reweighting.expectation_value_from_timeseries_log","text":"timeseries reweighting \n\ncan be used with methods:\n\nmetropolis         (for each temperature separate)\nparallel tempering (for each temperature separate)\nmulticanonical\npopulation annealing?\n\ncanonical <O> = sum Oi Ptarget(Ei)/Psource(Ei) / sum Ptarget(Ei)/Psource(args_i)\n\nor in general <O> = sum Oi Ptarget(argsi)/Psource(argsi) / sum Ptarget(argsi)/Psource(args_i)\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Reweighting.log_sum-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractFloat","page":"Home","title":"MonteCarloX.Reweighting.log_sum","text":"log_sum(a::T,b::T)\n\nReturn result of logarithmic sum c = ln(A+B) = a + ln(1+e^b-a) where C = e^c = A+B = e^a + e^b. \n\nThis is useful for sums that involve elements that span multiple orders of magnitude, e.g., the partition sum that is required as normalization factor during reweighting.\n\nExamples\n\njulia> exp(MonteCarloX.log_sum(log(2.), log(3.)))\n5.000000000000001\n\n\n\n\n\n\n","category":"method"},{"location":"#Non-equilibrium-Tools-1","page":"Home","title":"Non-equilibrium Tools","text":"","category":"section"},{"location":"#Kintetic-Monte-Carlo-1","page":"Home","title":"Kintetic Monte-Carlo","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Modules = [KineticMonteCarlo, Gillespie]","category":"page"},{"location":"#MonteCarloX.KineticMonteCarlo","page":"Home","title":"MonteCarloX.KineticMonteCarlo","text":"MonteCarloX.KineticMonteCarlo\n\nModule that allows to implement (rejection-free) kinetic Monte Carlo algorithms in general\n\n\n\n\n\n","category":"module"},{"location":"#MonteCarloX.KineticMonteCarlo.binary_search-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T<:Real","page":"Home","title":"MonteCarloX.KineticMonteCarlo.binary_search","text":"binary_search(sorted::AbstractVector{T}, value::T)::Int where {T<:Real}\n\nPerfom a binary search to return the index i of an sorted array such that sorted[i-1] < value <= sorted[i]\n\nExamples\n\njulia> MonteCarloX.binary_search([1.,2.,3.,4.],2.5)\n3\n\njulia> MonteCarloX.binary_search([1,2,3,4],2)\n2\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.KineticMonteCarlo.log_sum-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractFloat","page":"Home","title":"MonteCarloX.KineticMonteCarlo.log_sum","text":"log_sum(a::T,b::T)\n\nReturn result of logarithmic sum c = ln(A+B) = a + ln(1+e^b-a) where C = e^c = A+B = e^a + e^b. \n\nThis is useful for sums that involve elements that span multiple orders of magnitude, e.g., the partition sum that is required as normalization factor during reweighting.\n\nExamples\n\njulia> exp(MonteCarloX.log_sum(log(2.), log(3.)))\n5.000000000000001\n\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.KineticMonteCarlo.next_event-Union{Tuple{T}, Tuple{Array{T,1},Random.AbstractRNG}} where T<:AbstractFloat","page":"Home","title":"MonteCarloX.KineticMonteCarlo.next_event","text":"generate events (dt,id) from a list of rates such that their occurence corresponds with their rate\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.KineticMonteCarlo.next_event-Union{Tuple{T}, Tuple{Array{T,1},T,Random.AbstractRNG}} where T<:AbstractFloat","page":"Home","title":"MonteCarloX.KineticMonteCarlo.next_event","text":"fast implementation of nexteventrate if sum(list_rates) is known\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.KineticMonteCarlo.next_event_id-Union{Tuple{T}, Tuple{Array{T,1},Float64,Random.AbstractRNG}} where T<:AbstractFloat","page":"Home","title":"MonteCarloX.KineticMonteCarlo.next_event_id","text":"next event id for list of stochastic events described by occurence rates and the sum over those\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.KineticMonteCarlo.next_event_id-Union{Tuple{T}, Tuple{Array{T,1},Random.AbstractRNG}} where T<:AbstractFloat","page":"Home","title":"MonteCarloX.KineticMonteCarlo.next_event_id","text":"next event id for list of stochastic events describes by cumulated rates vector\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.KineticMonteCarlo.next_event_time-Tuple{Float64,Random.AbstractRNG}","page":"Home","title":"MonteCarloX.KineticMonteCarlo.next_event_time","text":"next event time for Poisson process with given rate\n\nArguments\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Gillespie","page":"Home","title":"MonteCarloX.Gillespie","text":"MonteCarloX.Gillespie\n\nModule that allows to implement Gillespie algorithm for the statistical time trajectory of a stochastic equation Uses kinetic Monte Carlo\n\n\n\n\n\n","category":"module"},{"location":"#MonteCarloX.Gillespie.advance-NTuple{4,Any}","page":"Home","title":"MonteCarloX.Gillespie.advance","text":"Advance the system by time T \n\nThe function generates new events as long as the total time increment does not go beyond the total time T. If the next event would advance the time too far, then this event is NOT performed. The system is thus in a state that it would have after time T. \n\nAssuming Poisson rates, the function can be called again to advance from time T because generation of events is independent. (TODO: check)\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Gillespie.next_event_rate-Tuple{Array,Float64,Random.AbstractRNG}","page":"Home","title":"MonteCarloX.Gillespie.next_event_rate","text":"fast implementation of nexteventrate if sum(list_rates) is known\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Gillespie.next_event_rate-Tuple{Array,Random.AbstractRNG}","page":"Home","title":"MonteCarloX.Gillespie.next_event_rate","text":"generate events (dt,id) from a list of rates such that their occurence corresponds with their rate\n\n\n\n\n\n","category":"method"},{"location":"#Inhomogeneous-Poisson-Process-1","page":"Home","title":"Inhomogeneous Poisson Process","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Modules = [InhomogeneousPoissonProcess]","category":"page"},{"location":"#MonteCarloX.InhomogeneousPoissonProcess","page":"Home","title":"MonteCarloX.InhomogeneousPoissonProcess","text":"Module MonteCarloX.InhomogeneousPoissonProcess\n\nbasic functions to evaluate (a coupled set of) inhomogeneous Poisson processes with time-dependent rate function rate(t)\n\n\n\n\n\n","category":"module"},{"location":"#MonteCarloX.InhomogeneousPoissonProcess.next_event_time-Tuple{Function,Float64,Random.AbstractRNG}","page":"Home","title":"MonteCarloX.InhomogeneousPoissonProcess.next_event_time","text":"nexteventtime(rate::Function, max_rate::Float64, rng::AbstractRNG)::Float64\n\nGenerate a new event from an inhomogeneous poisson process with rate Lambda(t). Based on (Ogata’s Modified Thinning Algorithm: Ogata,  1981,  p.25,  Algorithm  2) see also https://www.math.fsu.edu/~ychen/research/Thinning%20algorithm.pdf\n\nArguments\n\nrate: rate(dt) has to be defined outside (e..g t-> rate(t+t0,args))\nmax_rate: maximal rate in near future (has to be evaluated externally)\nrng: random number generator\n\nAPI - output\n\nreturns the next event time\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.InhomogeneousPoissonProcess.next_event_time_for_piece_wise_decreasing_rate-Tuple{Function,Random.AbstractRNG}","page":"Home","title":"MonteCarloX.InhomogeneousPoissonProcess.next_event_time_for_piece_wise_decreasing_rate","text":"Generate a new event from an inhomogeneous poisson process with rate Lambda(t) under the assumption that rate(dt) is monotonically decreasing. Based on (Ogata’s Modified Thinning Algorithm: Ogata,  1981,  p.25,  Algorithm  3) see also https://www.math.fsu.edu/~ychen/research/Thinning%20algorithm.pdf\n\nArguments\n\nrate: rate(dt) has to be defined outside (e..g t-> rate(t+t0,args))\nrng: random number generator\n\nAPI - output\n\nreturns the next event time\n\n\n\n\n\n","category":"method"},{"location":"#Helper-Modules-and-Functioms-1","page":"Home","title":"Helper Modules and Functioms","text":"","category":"section"},{"location":"#Histograms-1","page":"Home","title":"Histograms","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Modules = [Histograms]","category":"page"},{"location":"#MonteCarloX.Histograms","page":"Home","title":"MonteCarloX.Histograms","text":"MonteCarloX.Histograms\n\nModule represents histograms/distributions as dictionaries and handles addition\n\n\n\n\n\n","category":"module"},{"location":"#MonteCarloX.Histograms.distribution-Union{Tuple{Tx}, Tuple{Array{Tx,1},Tx,Tx}} where Tx<:Real","page":"Home","title":"MonteCarloX.Histograms.distribution","text":"create a distribution (sum_args dist[args] = 1) from a list of values\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.Histograms.histogram-Union{Tuple{Tv}, Tuple{Tx}, Tuple{Array{Tx,1},Tx,Tx}} where Tv<:Real where Tx<:Real","page":"Home","title":"MonteCarloX.Histograms.histogram","text":"create a histogram from a list of values\n\ncan this be formulated for listargs, dargs, argsref\n\n\n\n\n\n","category":"method"},{"location":"#Remaining-helper-1","page":"Home","title":"Remaining helper","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Modules = [MonteCarloX]","category":"page"},{"location":"#MonteCarloX.binary_search-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T<:Real","page":"Home","title":"MonteCarloX.binary_search","text":"binary_search(sorted::AbstractVector{T}, value::T)::Int where {T<:Real}\n\nPerfom a binary search to return the index i of an sorted array such that sorted[i-1] < value <= sorted[i]\n\nExamples\n\njulia> MonteCarloX.binary_search([1.,2.,3.,4.],2.5)\n3\n\njulia> MonteCarloX.binary_search([1,2,3,4],2)\n2\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.log_sum-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractFloat","page":"Home","title":"MonteCarloX.log_sum","text":"log_sum(a::T,b::T)\n\nReturn result of logarithmic sum c = ln(A+B) = a + ln(1+e^b-a) where C = e^c = A+B = e^a + e^b. \n\nThis is useful for sums that involve elements that span multiple orders of magnitude, e.g., the partition sum that is required as normalization factor during reweighting.\n\nExamples\n\njulia> exp(MonteCarloX.log_sum(log(2.), log(3.)))\n5.000000000000001\n\n\n\n\n\n\n","category":"method"}]
}
