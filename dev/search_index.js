var documenterSearchIndex = {"docs":
[{"location":"core_abstractions/#Core-Abstractions","page":"Core Abstractions","title":"Core Abstractions","text":"These abstractions are the stable conceptual backbone of MonteCarloX.","category":"section"},{"location":"core_abstractions/#AbstractSystem","page":"Core Abstractions","title":"AbstractSystem","text":"Represents the model state (configuration, constraints, cached observables, etc.). The system decides what can happen and how to compute quantities such as energy.","category":"section"},{"location":"core_abstractions/#AbstractLogWeight","page":"Core Abstractions","title":"AbstractLogWeight","text":"Represents the target log-weight for equilibrium sampling. For canonical simulations this is usually Boltzmann-like. For generalized ensembles this can be tabulated and updated online.","category":"section"},{"location":"core_abstractions/#AbstractAlgorithm","page":"Core Abstractions","title":"AbstractAlgorithm","text":"Represents the Monte Carlo engine (Metropolis, HeatBath, Gillespie, ...). It usually stores RNG and statistics (steps, acceptance counters, simulation time).","category":"section"},{"location":"core_abstractions/#AbstractUpdate","page":"Core Abstractions","title":"AbstractUpdate","text":"Represents update logic coordinating algorithm and state evolution. In practice, user-facing updates are often model functions (e.g. spin_flip!).","category":"section"},{"location":"core_abstractions/#AbstractMeasurement","page":"Core Abstractions","title":"AbstractMeasurement","text":"Represents observable extraction and storage. MonteCarloX provides Measurement and Measurements with scheduling.","category":"section"},{"location":"core_abstractions/#API-reference","page":"Core Abstractions","title":"API reference","text":"","category":"section"},{"location":"core_abstractions/#MonteCarloX.AbstractSystem","page":"Core Abstractions","title":"MonteCarloX.AbstractSystem","text":"AbstractSystem\n\nBase type for all systems in MonteCarloX.\n\nA system contains:\n\nState and constraints\nFor equilibrium: spins, particles, configuration\nFor non-equilibrium: population, rates, state variables\nIn Bayesian case: data and latent variables\nEverything needed to calculate log_weight or rates\n\nExamples:\n\nEquilibrium: Ising model, particle system\nNon-equilibrium: Birth-death process, SIR model\nBayesian: Hierarchical model with latent variables\n\n\n\n\n\n","category":"type"},{"location":"core_abstractions/#MonteCarloX.AbstractLogWeight","page":"Core Abstractions","title":"MonteCarloX.AbstractLogWeight","text":"AbstractLogWeight\n\nBase type for log weight functions.\n\nA LogWeight is:\n\nA callable object or function that operates on a system\nMay store parameters (e.g., temperature β for Boltzmann)\nMay include a measure (for multicanonical, continuous functions, etc.)\nIn Bayesian case: loglikelihood + logprior\n\n\n\n\n\n","category":"type"},{"location":"core_abstractions/#MonteCarloX.AbstractAlgorithm","page":"Core Abstractions","title":"MonteCarloX.AbstractAlgorithm","text":"AbstractAlgorithm\n\nBase type for all Monte Carlo algorithms.\n\nAn Algorithm:\n\nRepresents the sampling/simulation method\nMay hold RNG, parameters, and statistics\nWorks with AbstractSystem\n\nExamples:\n\nEquilibrium: Metropolis, Heat Bath, Cluster updates\nNon-equilibrium: Gillespie, Kinetic Monte Carlo, point-process models\n\n\n\n\n\n","category":"type"},{"location":"core_abstractions/#MonteCarloX.AbstractUpdate","page":"Core Abstractions","title":"MonteCarloX.AbstractUpdate","text":"AbstractUpdate\n\nBase type for update methods.\n\nAn Update is:\n\nA function that operates on (System, Algorithm)\nCoordinates how system and logweight interact\nShould be as general as possible for pre-implemented versions\n\n\n\n\n\n","category":"type"},{"location":"core_abstractions/#MonteCarloX.AbstractMeasurement","page":"Core Abstractions","title":"MonteCarloX.AbstractMeasurement","text":"AbstractMeasurement\n\nBase type for measurement objects.\n\n\n\n\n\n","category":"type"},{"location":"helper/#Helper-Tools","page":"Helper","title":"Helper Tools","text":"This page collects utility functions used across algorithms and model code.","category":"section"},{"location":"helper/#Numeric-helpers","page":"Helper","title":"Numeric helpers","text":"","category":"section"},{"location":"helper/#RNG-utilities","page":"Helper","title":"RNG utilities","text":"","category":"section"},{"location":"helper/#Event-handler-utilities","page":"Helper","title":"Event handler utilities","text":"","category":"section"},{"location":"helper/#MonteCarloX.log_sum","page":"Helper","title":"MonteCarloX.log_sum","text":"log_sum(a::T,b::T)\n\nReturn result of logarithmic sum c = ln(A+B) = a + ln(1+e^b-a) where C = e^c = A+B = e^a + e^b.\n\nThis is useful for sums that involve elements that span multiple orders of magnitude, e.g., the partition sum that is required as normalization factor during reweighting.\n\nExamples\n\njulia> exp(MonteCarloX.log_sum(log(2.), log(3.)))\n5.000000000000001\n\n\n\n\n\n\n","category":"function"},{"location":"helper/#MonteCarloX.binary_search","page":"Helper","title":"MonteCarloX.binary_search","text":"binary_search(sorted::AbstractVector{T}, value::T)::Int where {T<:Real}\n\nPerform a binary search to return the index i of an sorted array such that sorted[i-1] < value <= sorted[i]\n\nExamples\n\njulia> MonteCarloX.binary_search([1.,2.,3.,4.],2.5)\n3\n\njulia> MonteCarloX.binary_search([1,2,3,4],2)\n2\n\n\n\n\n\n","category":"function"},{"location":"helper/#MonteCarloX.logistic","page":"Helper","title":"MonteCarloX.logistic","text":"logistic(x::Real)\n\nNumerically stable logistic sigmoid:\n\nσ(x) = 1 / (1 + exp(-x))\n\n\n\n\n\n","category":"function"},{"location":"helper/#StatsBase.kldivergence","page":"Helper","title":"StatsBase.kldivergence","text":"kldivergence(P::Histogram, Q::Function)\n\nKullback-Leibler divergence between an empirical distribution (measured) and a reference distribution (analytic)\n\nSo far this is defined only for 1-dimensional distributions of type StatsBase.Histogram\n\n\n\n\n\n","category":"function"},{"location":"helper/#MonteCarloX.MutableRandomNumbers","page":"Helper","title":"MonteCarloX.MutableRandomNumbers","text":"MutableRandomNumbers([rng_base=GLOBAL_RNG], size, mode:=static)\n\nCreate a MutableRandomNumbers RNG object with a vector of size size containing floating-point randomnumbers initially generated with `rngbase`. Random numbers are then generated sequentially from this vector. The RNG object can be initialized in two modes:\n\n:static - then there is an exception thrown once all random numbers are used\n:dynamic - then there are new random numbers generated on the flow from the (copied) rng\n\nExamples\n\njulia> rng = MutableRandomNumbers(MersenneTwister(1234),100);\n\njulia> x1 = rand(rng, 2)\n2-element Array{Float64,1}:\n 0.5908446386657102\n 0.7667970365022592\n\njulia> rng = MersenneTwister(1234);\n\njulia> x2 = rand(rng, 2)\n2-element Array{Float64,1}:\n 0.5908446386657102\n 0.7667970365022592\n\njulia> x1 == x2\ntrue\n\nImportantly, the random numbers can be accessed and manipulated as in ordinary array objects.\n\njulia> rng[1]\n0.5908446386657102\njulia> rng[3] = 0.2\njulia> rand(rng)\n0.2\n\nUse reset in order to rerun the (manipulated) random number sequence.\n\njulia> reset(rng)\n\n\n\n\n\n\n","category":"type"},{"location":"helper/#Base.reset","page":"Helper","title":"Base.reset","text":"reset(rng::MutableRandomNumbers, [index::Int=0])\n\nReset the state of a MutableRandomNumbers object rng to index. Default resets the RNG object to the pre-initial index (0)\n\n\n\n\n\n","category":"function"},{"location":"helper/#MonteCarloX.ListEventRateSimple","page":"Helper","title":"MonteCarloX.ListEventRateSimple","text":"ListEventRateSimple{T}\n\nSimplest event manager for a list of events of type T with a static list of rates.\n\nAPI implemented\n\nlength(event_handler)\ngetindex(event_handler, index)\nsetindex!(event_handler, value, index)\n\n\n\n\n\n","category":"type"},{"location":"helper/#MonteCarloX.ListEventRateActiveMask","page":"Helper","title":"MonteCarloX.ListEventRateActiveMask","text":"ListEventRateActiveMask{T}\n\nEvent manager with explicit active-mask tracking for sparse active rates.\n\n\n\n\n\n","category":"type"},{"location":"helper/#MonteCarloX.EventQueue","page":"Helper","title":"MonteCarloX.EventQueue","text":"EventQueue{T}([start_time::Float64])\n\nOrdered time-event queue storing (time, event) tuples.\n\nAPI implemented\n\nlength(event_handler)\ngetindex(event_handler, index)\npopfirst!(event_handler)\nadd!(event_handler, tuple_time_event)\nget_time(event_handler)\nset_time!(event_handler, time)\n\n\n\n\n\n","category":"type"},{"location":"systems/#Systems-and-model-packages","page":"Systems","title":"Systems and model packages","text":"MonteCarloX intentionally does not hard-code specific physical models. Instead, models live in dedicated packages/modules and implement system-side methods.","category":"section"},{"location":"systems/#Example:-SpinSystems","page":"Systems","title":"Example: SpinSystems","text":"SpinSystems provides concrete Ising/Blume-Capel systems and update methods compatible with MonteCarloX algorithms.\n\nusing Random\nusing MonteCarloX\nusing SpinSystems\n\nrng = MersenneTwister(123)\nsys = Ising([32, 32], J=1, periodic=true)\ninit!(sys, :random, rng=rng)\n\nalg = Metropolis(rng; β=0.44)\nfor _ in 1:10_000\n    spin_flip!(sys, alg)\nend\n\nprintln(energy(sys), magnetization(sys))","category":"section"},{"location":"systems/#What-a-custom-system-should-provide","page":"Systems","title":"What a custom system should provide","text":"At minimum, your model package should expose:\n\nstate representation (your concrete subtype of AbstractSystem)\nobservables needed by your analysis (energy, order parameters, ...)\nupdate hooks compatible with target algorithm(s)\ninitialization and reproducibility controls\n\nThis design keeps MonteCarloX reusable while allowing domain-specific model code to evolve independently.","category":"section"},{"location":"framework/#Framework:-how-to-think-in-MonteCarloX","page":"Framework","title":"Framework: how to think in MonteCarloX","text":"MonteCarloX is designed around composable parts instead of one monolithic simulator. A simulation is built by combining:\n\nSystem (AbstractSystem): what state you evolve\nWeight / rates (AbstractLogWeight or rates): what distribution/dynamics define probability\nAlgorithm (AbstractAlgorithm): how proposals/events are generated\nUpdate (AbstractUpdate + model-side methods): how accepted events modify state\nMeasurement (Measurement, Measurements): what observables are recorded\n\nThis separation is intentional:\n\nYou can keep the same algorithm and swap in a different system.\nYou can keep the same system and change the ensemble via a different log weight.\nYou can reuse a measurement setup across multiple algorithms.","category":"section"},{"location":"framework/#Two-sampling-paradigms","page":"Framework","title":"Two sampling paradigms","text":"MonteCarloX supports two complementary paradigms:","category":"section"},{"location":"framework/#Importance-sampling","page":"Framework","title":"Importance sampling","text":"System + LogWeight + Proposal/Accept + Apply + Measure\n\nPrimary goal: sample from a target stationary distribution.","category":"section"},{"location":"framework/#Continuous-time-sampling","page":"Framework","title":"Continuous-time sampling","text":"State + Event rates + Sampler + Measure + Apply\n\nPrimary goal: evolve stochastic dynamics in physical/simulation time.\n\nIn continuous-time workflows, the sampler provides (dt, event) and advances time, then measurements are taken at the new time before applying the event update.","category":"section"},{"location":"framework/#Minimal-importance-sampling-workflow","page":"Framework","title":"Minimal importance-sampling workflow","text":"using Random\nusing MonteCarloX\nusing SpinSystems\n\nrng = MersenneTwister(42)\nsys = Ising([16, 16], J=1, periodic=true)\ninit!(sys, :random, rng=rng)\n\nalg = Metropolis(rng; β=0.4)\n\nmeasurements = Measurements([\n    :energy => energy => Float64[],\n    :magnetization => magnetization => Float64[]\n], interval=10)\n\nfor step in 1:100_000\n    spin_flip!(sys, alg)\n    measure!(measurements, sys, step)\nend","category":"section"},{"location":"framework/#Minimal-continuous-time-workflow","page":"Framework","title":"Minimal continuous-time workflow","text":"using Random\nusing MonteCarloX\n\nrng = MersenneTwister(123)\nalg = Gillespie(rng)\n\nrates = [1.0, 2.0, 0.2]  # event intensities\n\nfor _ in 1:10_000\n    t, event = step!(alg, rates)\n    # 1) measure at time t\n    # 2) apply event update to state\n    # 3) refresh rates if needed\nend","category":"section"},{"location":"framework/#Where-to-go-next","page":"Framework","title":"Where to go next","text":"Core Abstractions\nWeights\nImportance Sampling Algorithms\nContinuous-Time Sampling Algorithms\nMeasurements\nSystems and model packages\nWorked Examples","category":"section"},{"location":"weights/#Weights","page":"Weights","title":"Weights","text":"In equilibrium Monte Carlo, a log weight defines relative probabilities. Algorithms consume log-weight differences through acceptance rules.","category":"section"},{"location":"weights/#Canonical-weight","page":"Weights","title":"Canonical weight","text":"BoltzmannLogWeight(β) is the default canonical choice.\n\nusing Random\nusing MonteCarloX\n\nrng = MersenneTwister(1)\nalg = Metropolis(rng; β=0.5)","category":"section"},{"location":"weights/#Mutable/tabulated-weight","page":"Weights","title":"Mutable/tabulated weight","text":"For generalized ensembles (multicanonical, Wang–Landau), TabulatedLogWeight stores a histogram-backed table that can be updated.\n\nusing MonteCarloX\nusing StatsBase\n\nedges = (collect(-10.0:1.0:10.0),)\nh = fit(Histogram, Float64[], edges)\nlw = TabulatedLogWeight(h)\n\n# or initialize directly from edges with a constant value\nlw0 = TabulatedLogWeight(-10.0:1.0:10.0, 0.0)\n\n# edges can be any sorted vector/range\nedges_vec = collect(-5.0:0.5:5.0)\nlw1 = TabulatedLogWeight(edges_vec, 0.0)\n\nlw[0.3] = 1.2\nw = lw(0.3)","category":"section"},{"location":"weights/#API-reference","page":"Weights","title":"API reference","text":"","category":"section"},{"location":"weights/#MonteCarloX.BoltzmannLogWeight","page":"Weights","title":"MonteCarloX.BoltzmannLogWeight","text":"BoltzmannLogWeight <: AbstractLogWeight\n\nBoltzmann weight function: w(E) = exp(-β*E).\n\nThis is the standard weight for canonical ensemble Monte Carlo simulations at a fixed inverse temperature β = 1/(k_B T).\n\nFields\n\nβ::Float64: Inverse temperature\n\nExamples\n\n# Create weight for temperature T=2.0 (assuming k_B = 1)\nlogweight = BoltzmannLogWeight(0.5)\n\n# Evaluate log weight for scalar energy\nlogw = logweight(-2.5)  # Returns -0.5 * (-2.5) = 1.25\n\n# Or for vector of energy terms\nlogw = logweight([-1, -2, -3])  # Returns -0.5 * (-6) = 3.0\n\n\n\n\n\n","category":"type"},{"location":"weights/#MonteCarloX.TabulatedLogWeight","page":"Weights","title":"MonteCarloX.TabulatedLogWeight","text":"TabulatedLogWeight <: AbstractLogWeight\n\nMutable tabulated log weight backed by a histogram.\n\nCalling with a scalar state value returns the current tabulated log weight at the corresponding histogram bin.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Worked-Examples","page":"Worked Examples","title":"Worked Examples","text":"This page maps common goals to runnable examples.","category":"section"},{"location":"examples/#1)-Equilibrium-Ising-with-Metropolis","page":"Worked Examples","title":"1) Equilibrium Ising with Metropolis","text":"Goal: sample canonical equilibrium and measure energy/magnetization.\n\nSee notebook: notebooks/simple_ising.ipynb\nMain pieces: Ising (system) + BoltzmannLogWeight via Metropolis(β=...) + Measurements","category":"section"},{"location":"examples/#2)-Branching-/-birth-death-process","page":"Worked Examples","title":"2) Branching / birth-death process","text":"Goal: simulate non-equilibrium stochastic population dynamics.\n\nSee notebook: notebooks/birth_death_process.ipynb\nMain pieces: state variables + rates + Gillespie + time-based measurements","category":"section"},{"location":"examples/#3)-Poisson-process-with-kinetic-Monte-Carlo-primitives","page":"Worked Examples","title":"3) Poisson process with kinetic Monte Carlo primitives","text":"Goal: simulate homogeneous and inhomogeneous Poisson processes.\n\nSee notebook: notebooks/poisson_kmc.ipynb\nMain pieces: next_time, next_event, next, step! and optional thinning callback","category":"section"},{"location":"examples/#4)-Generalized-ensemble-(multicanonical-/-Wang–Landau)","page":"Worked Examples","title":"4) Generalized ensemble (multicanonical / Wang–Landau)","text":"Goal: adapt weights online to flatten histogram / estimate DOS.\n\nMain pieces: TabulatedLogWeight, Multicanonical or WangLandau, update_weight!, update_f!\nStart from equilibrium example and replace canonical weight with tabulated weight updates","category":"section"},{"location":"examples/#Suggested-reading-order","page":"Worked Examples","title":"Suggested reading order","text":"Framework\nCore abstractions\nWeights\nEquilibrium or non-equilibrium algorithm page (depending on your project)\nMeasurements\nThis examples page + notebooks","category":"section"},{"location":"importance_sampling_algorithms/#Importance-Sampling-Algorithms","page":"Importance Sampling Algorithms","title":"Importance Sampling Algorithms","text":"Importance-sampling workflows in MonteCarloX use accept/reject-style updates to target a specified distribution. You combine:\n\na system that defines state and local updates,\na log weight (BoltzmannLogWeight or tabulated variants),\nan algorithm that accepts/rejects proposals.","category":"section"},{"location":"importance_sampling_algorithms/#Metropolis-family-algorithms","page":"Importance Sampling Algorithms","title":"Metropolis-family algorithms","text":"Metropolis and Glauber share the same log-ratio interface but use different acceptance rules.\n\nTypical model-side update methods compute a local energy change and call accept! through algorithm helpers.\n\nusing Random\nusing MonteCarloX\nusing SpinSystems\n\nrng = MersenneTwister(42)\nsys = Ising([16, 16], J=1, periodic=true)\ninit!(sys, :random, rng=rng)\n\nalg = Metropolis(rng; β=0.4)\n\nfor _ in 1:50_000\n    spin_flip!(sys, alg)\nend\n\nprintln(\"acceptance = \", acceptance_rate(alg))","category":"section"},{"location":"importance_sampling_algorithms/#Heat-bath-updates","page":"Importance Sampling Algorithms","title":"Heat-bath updates","text":"HeatBath uses conditional local probabilities instead of accept/reject logic. This can improve mixing for some model classes.","category":"section"},{"location":"importance_sampling_algorithms/#Generalized-ensembles","page":"Importance Sampling Algorithms","title":"Generalized ensembles","text":"Multicanonical targets flat-histogram-like exploration by evolving a tabulated log weight.\nWangLandau iteratively updates density-of-states estimates and refinement parameter f.\n\nusing Random\nusing MonteCarloX\n\nrng = MersenneTwister(7)\nalg = WangLandau(rng)\n\n# update_weight! and update_f! are called in your simulation loop","category":"section"},{"location":"importance_sampling_algorithms/#API-reference","page":"Importance Sampling Algorithms","title":"API reference","text":"","category":"section"},{"location":"importance_sampling_algorithms/#MonteCarloX.AbstractImportanceSampling","page":"Importance Sampling Algorithms","title":"MonteCarloX.AbstractImportanceSampling","text":"AbstractImportanceSampling <: AbstractAlgorithm\n\nBase type for importance sampling algorithms (Metropolis, Heat Bath, etc.).\n\nImportance sampling algorithms:\n\nUse accept/reject steps based on log weight ratios\nTrack acceptance statistics\nInclude an RNG and a log weight function\n\n\n\n\n\n","category":"type"},{"location":"importance_sampling_algorithms/#MonteCarloX.AbstractGeneralizedEnsemble","page":"Importance Sampling Algorithms","title":"MonteCarloX.AbstractGeneralizedEnsemble","text":"AbstractGeneralizedEnsemble <: AbstractImportanceSampling\n\nBase type for generalized-ensemble samplers (e.g. multicanonical, Wang-Landau).\n\n\n\n\n\n","category":"type"},{"location":"importance_sampling_algorithms/#MonteCarloX.AbstractMetropolis","page":"Importance Sampling Algorithms","title":"MonteCarloX.AbstractMetropolis","text":"AbstractMetropolis <: AbstractImportanceSampling\n\nBase type for Metropolis-family samplers where acceptance is naturally computed from a local state difference (e.g. ΔE).\n\n\n\n\n\n","category":"type"},{"location":"importance_sampling_algorithms/#MonteCarloX.AbstractHeatBath","page":"Importance Sampling Algorithms","title":"MonteCarloX.AbstractHeatBath","text":"AbstractHeatBath <: AbstractAlgorithm\n\nBase type for heat-bath style samplers.\n\n\n\n\n\n","category":"type"},{"location":"importance_sampling_algorithms/#MonteCarloX.Metropolis","page":"Importance Sampling Algorithms","title":"MonteCarloX.Metropolis","text":"Metropolis <: AbstractImportanceSampling\n\nMetropolis algorithm for importance sampling.\n\nThe Metropolis algorithm samples from a probability distribution  proportional to exp(log_weight) using an accept/reject criterion.\n\nFields\n\nrng::AbstractRNG: Random number generator\nlogweight::Union{AbstractLogWeight, Function}: Log weight function\nsteps::Int: Total number of steps attempted\naccepted::Int: Number of accepted steps\n\nExamples\n\n# Create with Boltzmann weight\nalg = Metropolis(Random.default_rng(), β=2.0)\n\n# Create with custom log weight function\nalg = Metropolis(Random.default_rng(), E -> -2.0 * sum(E))\n\n# Create with a weight object\nlogweight = BoltzmannLogWeight(1.5)\nalg = Metropolis(Random.default_rng(), logweight)\n\n\n\n\n\n","category":"type"},{"location":"importance_sampling_algorithms/#MonteCarloX.Glauber","page":"Importance Sampling Algorithms","title":"MonteCarloX.Glauber","text":"Glauber <: AbstractMetropolis\n\nGlauber sampler with logistic acceptance rule.\n\nUses the same proposal interface and log-ratio as Metropolis-family algorithms, but acceptance is:\n\np_accept = 1 / (1 + exp(-log_ratio))\n\n\n\n\n\n","category":"type"},{"location":"importance_sampling_algorithms/#MonteCarloX.HeatBath","page":"Importance Sampling Algorithms","title":"MonteCarloX.HeatBath","text":"HeatBath <: AbstractHeatBath\n\nHeat-bath sampler parameters.\n\nFor Ising-like systems, updates draw directly from the local conditional probability using inverse temperature β.\n\n\n\n\n\n","category":"type"},{"location":"importance_sampling_algorithms/#MonteCarloX.accept!","page":"Importance Sampling Algorithms","title":"MonteCarloX.accept!","text":"accept!(alg::AbstractImportanceSampling, log_ratio::Real)\n\nEvaluate acceptance criterion for importance sampling.\n\nUpdates step and acceptance counters in the algorithm. Returns true if the move is accepted based on the Metropolis criterion:\n\nAccept if log_ratio > 0 (new state has higher weight)\nAccept with probability exp(log_ratio) otherwise\n\nThis is the core accept/reject step used by all importance sampling algorithms.\n\n\n\n\n\n","category":"function"},{"location":"importance_sampling_algorithms/#MonteCarloX.acceptance_rate","page":"Importance Sampling Algorithms","title":"MonteCarloX.acceptance_rate","text":"acceptance_rate(alg::AbstractImportanceSampling)\n\nCalculate the acceptance rate of the algorithm.\n\nReturns the fraction of accepted moves: accepted/steps. Returns 0.0 if no steps have been attempted yet.\n\n\n\n\n\n","category":"function"},{"location":"importance_sampling_algorithms/#MonteCarloX.reset_statistics!","page":"Importance Sampling Algorithms","title":"MonteCarloX.reset_statistics!","text":"reset_statistics!(alg::AbstractImportanceSampling)\n\nReset step and acceptance counters to zero.\n\nUseful when you want to measure acceptance rate for a specific run phase without previous history.\n\n\n\n\n\nreset_statistics!(alg::AbstractKineticMonteCarlo)\n\nReset kinetic Monte Carlo statistics (steps, time) to zero.\n\n\n\n\n\n","category":"function"},{"location":"importance_sampling_algorithms/#MonteCarloX.log_acceptance_ratio","page":"Importance Sampling Algorithms","title":"MonteCarloX.log_acceptance_ratio","text":"log_acceptance_ratio(alg::AbstractMetropolis, delta_state)\n\nDefault log-acceptance ratio for Metropolis-family updates from a local state difference.\n\n\n\n\n\nlog_acceptance_ratio(alg::AbstractImportanceSampling, state_new, state_old)\n\nGeneral log-acceptance ratio for importance sampling algorithms that require absolute state values.\n\n\n\n\n\n","category":"function"},{"location":"importance_sampling_algorithms/#MonteCarloX.Multicanonical","page":"Importance Sampling Algorithms","title":"MonteCarloX.Multicanonical","text":"Multicanonical <: AbstractImportanceSampling\n\nGeneralized-ensemble importance sampling algorithm.\n\nThe algorithm tracks standard acceptance statistics and stores a tabulated log-weight estimate.\n\nNotation used here:\n\nΩ(E): density of states\nS(E) = log Ω(E): microcanonical entropy estimate\nlogWeight(E) = S(E) stored in alg.logweight\n\n\n\n\n\n","category":"type"},{"location":"importance_sampling_algorithms/#MonteCarloX.WangLandau","page":"Importance Sampling Algorithms","title":"MonteCarloX.WangLandau","text":"WangLandau <: AbstractImportanceSampling\n\nWang-Landau generalized-ensemble sampler.\n\nNotation used here:\n\ng(E): density of states estimate\nS(E) = log g(E): entropy estimate\nlogWeight(E) = S(E) stored in alg.logweight\nlogf = log(f): logarithmic modification factor\n\nEach visit to an energy bin E_i applies the local update S(E_i) <- S(E_i) + logf. In this API convention this appears as alg.logweight[E_i] -= logf.\n\n\n\n\n\n","category":"type"},{"location":"importance_sampling_algorithms/#MonteCarloX.update_weight!","page":"Importance Sampling Algorithms","title":"MonteCarloX.update_weight!","text":"update_weight!(alg::WangLandau, x)\n\nApply one local Wang-Landau update at x:\n\nalg.logweight[x] -= alg.logf\n\nMutates in place and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"importance_sampling_algorithms/#MonteCarloX.update_f!","page":"Importance Sampling Algorithms","title":"MonteCarloX.update_f!","text":"update_f!(alg::WangLandau)\n\nUpdate Wang-Landau schedule in-place with logf <- 0.5 * logf (equivalent to f <- sqrt(f)).\n\n\n\n\n\n","category":"function"},{"location":"importance_sampling_algorithms/#MonteCarloX.update_weights!","page":"Importance Sampling Algorithms","title":"MonteCarloX.update_weights!","text":"update_weights!(alg::Multicanonical, histogram::Histogram; mode=:simple)\n\nUpdate multicanonical log-weights from a sampling histogram in-place.\n\nCurrently implemented mode:\n\n:simple: for visited bins, perform   logWeight(E) <- logWeight(E) - log(H(E)).\n\nThis mutates alg.logweight and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"#MonteCarloX.jl","page":"Getting Started","title":"MonteCarloX.jl","text":"MonteCarloX is a composable framework for Monte Carlo simulations in Julia. It supports equilibrium and non-equilibrium workflows while keeping model code separate from algorithmic code.","category":"section"},{"location":"#Philosophy","page":"Getting Started","title":"Philosophy","text":"The core design principle is separation of concerns:\n\nSystem: state and model-specific operations\nWeight/rates: probability structure (equilibrium) or event intensities (dynamics)\nAlgorithm: how proposals/events are sampled\nUpdate: how accepted events modify state\nMeasurement: what is recorded and when\n\nThis allows reusable algorithm templates where systems can be swapped without rewriting the simulation driver.","category":"section"},{"location":"#Documentation-roadmap","page":"Getting Started","title":"Documentation roadmap","text":"If you are new to the package, read in this order:\n\nFramework\nCore Abstractions\nWeights\nImportance Sampling or Continuous-Time Sampling Algorithms\nMeasurements\nSystems\nWorked Examples","category":"section"},{"location":"#Scope","page":"Getting Started","title":"Scope","text":"MonteCarloX contains the algorithmic and infrastructure core. Concrete model families are expected to live in companion packages/modules, such as SpinSystems.","category":"section"},{"location":"#Contributing","page":"Getting Started","title":"Contributing","text":"The API is actively refined. Contributions are welcome, especially around examples, docs coverage, and cross-domain model integrations.","category":"section"},{"location":"measurements/#Measurements","page":"Measurements","title":"Measurements","text":"Measurements are first-class objects in MonteCarloX. You define observables once and choose a schedule separately.","category":"section"},{"location":"measurements/#Building-a-measurement-set","page":"Measurements","title":"Building a measurement set","text":"using MonteCarloX\n\nmeasurements = Measurements([\n    :energy => energy => Float64[],\n    :magnetization => magnetization => Float64[]\n], interval=10)\n\nThis uses IntervalSchedule and records every 10 steps (or time units, depending on your loop variable).","category":"section"},{"location":"measurements/#Preallocated-schedule","page":"Measurements","title":"Preallocated schedule","text":"For event-driven simulations, pre-defined measurement times are often better:\n\ntimes = collect(0.0:0.1:10.0)\nmeasurements = Measurements([\n    :x => state_value => Float64[]\n], times)\n\n# in simulation loop\nmeasure!(measurements, system, t)\nif is_complete(measurements)\n    # all target times were measured\nend","category":"section"},{"location":"measurements/#API-reference","page":"Measurements","title":"API reference","text":"","category":"section"},{"location":"measurements/#MonteCarloX.Measurement","page":"Measurements","title":"MonteCarloX.Measurement","text":"Measurement{F,T}\n\nA measurement consisting of an observable function and a data container.\n\nFields\n\nobservable::F: Function that extracts a value from the system\ndata::T: Container for storing measurements (Vector, Histogram, etc.)\n\n\n\n\n\n","category":"type"},{"location":"measurements/#MonteCarloX.Measurements","page":"Measurements","title":"MonteCarloX.Measurements","text":"Measurements{K,S<:MeasurementSchedule}\n\nContainer for multiple measurements with a shared schedule.\n\nFields\n\nmeasurements::Dict{K, Measurement}: Dictionary of named measurements\nschedule::S: Measurement schedule\n\n\n\n\n\n","category":"type"},{"location":"measurements/#MonteCarloX.MeasurementSchedule","page":"Measurements","title":"MonteCarloX.MeasurementSchedule","text":"MeasurementSchedule\n\nAbstract type for different measurement scheduling strategies.\n\n\n\n\n\n","category":"type"},{"location":"measurements/#MonteCarloX.IntervalSchedule","page":"Measurements","title":"MonteCarloX.IntervalSchedule","text":"IntervalSchedule <: MeasurementSchedule\n\nSchedule measurements at regular intervals.\n\nFields\n\ninterval::Float64: Time/step interval between measurements\n_checkpoint::Float64: Internal checkpoint for next measurement\n\n\n\n\n\n","category":"type"},{"location":"measurements/#MonteCarloX.PreallocatedSchedule","page":"Measurements","title":"MonteCarloX.PreallocatedSchedule","text":"PreallocatedSchedule <: MeasurementSchedule\n\nSchedule measurements at pre-specified times.\n\nFields\n\ntimes::Vector{Float64}: Sorted vector of measurement times\ncheckpoint_idx::Int: Current index in times vector\n\n\n\n\n\n","category":"type"},{"location":"measurements/#MonteCarloX.measure!","page":"Measurements","title":"MonteCarloX.measure!","text":"measure!(measurement::Measurement, sys; kwargs...)\n\nPerform a single measurement by evaluating the observable on the system and storing the result.\n\n\n\n\n\nmeasure!(measurements::Measurements{K, IntervalSchedule}, sys, t; kwargs...)\n\nPerform measurements at regular intervals (indefinite simulation).\n\n\n\n\n\nmeasure!(measurements::Measurements{K, PreallocatedSchedule}, sys, t; kwargs...)\n\nPerform measurements at preallocated times (handles event skipping).\n\n\n\n\n\n","category":"function"},{"location":"measurements/#MonteCarloX.reset!-Tuple{Measurement}","page":"Measurements","title":"MonteCarloX.reset!","text":"reset!(measurement::Measurement)\n\nReset a single measurement to its initial state by clearing its data container. For histogram-backed measurements this zeros the bin counts while preserving binning.\n\n\n\n\n\n","category":"method"},{"location":"measurements/#MonteCarloX.reset!-Tuple{IntervalSchedule}","page":"Measurements","title":"MonteCarloX.reset!","text":"reset!(schedule::MeasurementSchedule)\n\nReset schedule counters/checkpoints back to their initial state.\n\n\n\n\n\n","category":"method"},{"location":"measurements/#MonteCarloX.reset!-Tuple{Measurements}","page":"Measurements","title":"MonteCarloX.reset!","text":"reset!(measurements::Measurements)\n\nReset all measurement data containers and schedule state in-place.\n\n\n\n\n\n","category":"method"},{"location":"measurements/#MonteCarloX.times-Union{Tuple{Measurements{K, PreallocatedSchedule}}, Tuple{K}} where K","page":"Measurements","title":"MonteCarloX.times","text":"times(m::Measurements)\n\nReturn the measurement time points for preallocated schedules.\n\n\n\n\n\n","category":"method"},{"location":"measurements/#MonteCarloX.data-Union{Tuple{K}, Tuple{Measurements{K, S} where S<:MeasurementSchedule, K}} where K","page":"Measurements","title":"MonteCarloX.data","text":"data(m::Measurements{K}, key::K)\n\nReturn the raw data container for a named measurement.\n\n\n\n\n\n","category":"method"},{"location":"measurements/#MonteCarloX.is_complete","page":"Measurements","title":"MonteCarloX.is_complete","text":"is_complete(m::Measurements)\n\nCheck if all scheduled measurements are complete. Returns false for interval-based schedules (indefinite).\n\n\n\n\n\n","category":"function"},{"location":"continuous_time_sampling_algorithms/#Continuous-Time-Sampling-Algorithms","page":"Continuous-Time Sampling Algorithms","title":"Continuous-Time Sampling Algorithms","text":"Non-equilibrium simulations are event-driven in MonteCarloX. The core primitive is kinetic Monte Carlo in continuous time.\n\nThis is distinct from importance sampling:\n\nImportance sampling targets a stationary distribution via accept/reject updates.\nContinuous-time sampling advances stochastic dynamics with sampled waiting times and events.","category":"section"},{"location":"continuous_time_sampling_algorithms/#Continuous-time-stepping-model","page":"Continuous-Time Sampling Algorithms","title":"Continuous-time stepping model","text":"The standard loop is:\n\nstart from current state,\ncompute/provide event rates,\nsample (dt, event) (which advances simulation time),\nmeasure at the new time,\napply event update to state,\nrefresh rates/event structure if needed.\n\nGillespie is the canonical user-facing algorithm for this pattern.","category":"section"},{"location":"continuous_time_sampling_algorithms/#Sources-for-event-sampling","page":"Continuous-Time Sampling Algorithms","title":"Sources for event sampling","text":"next / step! work with multiple backends:\n\nraw rates (AbstractVector)\nweighted rates (AbstractWeights)\nevent handlers (AbstractEventHandlerRate, AbstractEventHandlerTime)\ntime-dependent rate callback (rates_at_time(alg.time) -> rates)","category":"section"},{"location":"continuous_time_sampling_algorithms/#Minimal-example","page":"Continuous-Time Sampling Algorithms","title":"Minimal example","text":"using Random\nusing MonteCarloX\n\nrng = MersenneTwister(11)\nalg = Gillespie(rng)\n\nrates = [0.1, 0.2, 0.05]\n\nfor _ in 1:10_000\n\tt, event = step!(alg, rates)\n\t# measure at time t\n\t# apply event to your model state\n\t# update rates if state changed\nend","category":"section"},{"location":"continuous_time_sampling_algorithms/#Poisson-process-perspective","page":"Continuous-Time Sampling Algorithms","title":"Poisson process perspective","text":"Homogeneous and inhomogeneous Poisson processes can be implemented directly with next_time, next_event, next, and optional thinning callbacks. See notebooks/poisson_kmc.ipynb for a full worked notebook.","category":"section"},{"location":"continuous_time_sampling_algorithms/#API-reference","page":"Continuous-Time Sampling Algorithms","title":"API reference","text":"","category":"section"},{"location":"continuous_time_sampling_algorithms/#MonteCarloX.AbstractKineticMonteCarlo","page":"Continuous-Time Sampling Algorithms","title":"MonteCarloX.AbstractKineticMonteCarlo","text":"AbstractKineticMonteCarlo <: AbstractAlgorithm\n\nBase type for continuous-time kinetic Monte Carlo algorithms.\n\nKinetic Monte Carlo algorithms:\n\nDraw waiting times from event rates\nDraw events proportional to rates\nTrack simulation time and number of accepted events\n\n\n\n\n\n","category":"type"},{"location":"continuous_time_sampling_algorithms/#MonteCarloX.Gillespie","page":"Continuous-Time Sampling Algorithms","title":"MonteCarloX.Gillespie","text":"Gillespie <: AbstractKineticMonteCarlo\n\nGillespie algorithm for continuous-time event-driven sampling.\n\nFields\n\nrng::AbstractRNG: Random number generator\nsteps::Int: Number of events sampled\ntime::Float64: Current simulation time\n\n\n\n\n\n","category":"type"},{"location":"continuous_time_sampling_algorithms/#MonteCarloX.next","page":"Continuous-Time Sampling Algorithms","title":"MonteCarloX.next","text":"next(alg::AbstractKineticMonteCarlo, rates::AbstractVector)\n\nDraw next event waiting time and event id from raw rates.\n\nFor zero total rate, returns (Inf, 0).\n\n\n\n\n\nnext(alg::AbstractKineticMonteCarlo, rates::AbstractVector)\n\nDraw next event waiting time and event id from raw rates.\n\nFor zero total rate, returns (Inf, 0).\n\n\n\n\n\nnext(alg::AbstractKineticMonteCarlo, rates::AbstractWeights)\n\nDraw next event waiting time and event id from weighted rates.\n\nFor zero total rate, returns (Inf, 0).\n\n\n\n\n\nnext(alg::AbstractKineticMonteCarlo, event_handler::AbstractEventHandlerRate)\n\nDraw next event waiting time and event from an event handler.\n\n\n\n\n\nnext(alg::AbstractKineticMonteCarlo, event_handler::AbstractEventHandlerTime)\n\nDraw next event from a time-ordered event queue.\n\n\n\n\n\nnext(alg::AbstractKineticMonteCarlo, rates_at_time::Function)\n\nDraw next event waiting time and event from a time-dependent rates function.\n\nrates_at_time is called as rates_at_time(alg.time) and should return either an AbstractVector, AbstractWeights, or AbstractEventHandlerRate.\n\n\n\n\n\n","category":"function"},{"location":"continuous_time_sampling_algorithms/#MonteCarloX.step!","page":"Continuous-Time Sampling Algorithms","title":"MonteCarloX.step!","text":"step!(alg::AbstractKineticMonteCarlo, rates::AbstractVector)\n\nPerform one kinetic Monte Carlo event from raw rates.\n\nUpdates alg.time and alg.steps internally and returns (t_new, event).\n\n\n\n\n\nstep!(alg::AbstractKineticMonteCarlo, rates::AbstractWeights)\n\nPerform one kinetic Monte Carlo event from weighted rates.\n\nUpdates alg.time and alg.steps internally and returns (t_new, event).\n\n\n\n\n\nstep!(alg::AbstractKineticMonteCarlo, event_handler::AbstractEventHandlerRate)\n\nPerform one kinetic Monte Carlo event from an event-handler backend.\n\nUpdates alg.time and alg.steps internally and returns (t_new, event).\n\n\n\n\n\nstep!(alg::AbstractKineticMonteCarlo, event_handler::AbstractEventHandlerTime)\n\nPerform one kinetic Monte Carlo event from a time-event handler backend.\n\nUpdates alg.time and alg.steps internally and returns (t_new, event).\n\n\n\n\n\nstep!(alg::AbstractKineticMonteCarlo, rates_at_time::Function)\n\nPerform one kinetic Monte Carlo event from a time-dependent rates callback.\n\nUpdates alg.time and alg.steps internally and returns (t_new, event).\n\n\n\n\n\n","category":"function"},{"location":"continuous_time_sampling_algorithms/#MonteCarloX.next_time","page":"Continuous-Time Sampling Algorithms","title":"MonteCarloX.next_time","text":"next_time(rng::AbstractRNG, rate_generation::Number)::Float64\n\nDraw next waiting time for a homogeneous Poisson event stream.\n\n\n\n\n\nnext_time(rng::AbstractRNG, rate::Function, rate_generation::Real)::Real\n\nDraw next waiting time for an inhomogeneous Poisson stream using thinning.\n\n\n\n\n\n","category":"function"},{"location":"continuous_time_sampling_algorithms/#MonteCarloX.next_event","page":"Continuous-Time Sampling Algorithms","title":"MonteCarloX.next_event","text":"next_event(rng::AbstractRNG, rates::Union{AbstractWeights, AbstractVector})::Int\n\nDraw one event index proportional to rates.\n\n\n\n\n\n","category":"function"},{"location":"continuous_time_sampling_algorithms/#MonteCarloX.advance!","page":"Continuous-Time Sampling Algorithms","title":"MonteCarloX.advance!","text":"advance!(alg::AbstractKineticMonteCarlo, rates::AbstractVector, total_time; t0=0, update!=nothing)\n\nAdvance a continuous-time process with raw rates until total_time.\n\nIf update! is provided, it is called as update!(rates, event, t_new) after each sampled event.\n\n\n\n\n\nadvance!(alg::AbstractKineticMonteCarlo, rates::AbstractWeights, total_time; t0=0, update!=nothing)\n\nAdvance a continuous-time process with weighted rates until total_time.\n\nIf update! is provided, it is called as update!(rates, event, t_new) after each sampled event.\n\n\n\n\n\nadvance!(alg::AbstractKineticMonteCarlo, event_handler::AbstractEventHandlerRate, total_time; t0=0, update!=nothing)\n\nAdvance a continuous-time process with an event-handler backend until total_time.\n\nIf update! is provided, it is called as update!(event_handler, event, t_new) after each sampled event.\n\n\n\n\n\nadvance!(alg::AbstractKineticMonteCarlo, event_handler::AbstractEventHandlerTime, total_time; t0=0, update!=nothing)\n\nAdvance a continuous-time process with a time-event handler until total_time.\n\nIf update! is provided, it is called as update!(event_handler, event, t_new) after each sampled event.\n\n\n\n\n\nadvance!(alg::AbstractKineticMonteCarlo, sys, total_time; rates, t0=0, measure!=nothing, update!=nothing)\n\nAdvance a model system where rates are provided explicitly via rates(sys, t) callback.\n\nIf measure! is provided, it is called before update as measure!(sys, t_new, event). If update! is provided, it is called as update!(sys, event, t_new).\n\nThis two-stage interface is useful for kinetic simulations where measurements are defined at event times before the event modifies the state.\n\n\n\n\n\n","category":"function"}]
}
