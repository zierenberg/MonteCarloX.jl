var documenterSearchIndex = {"docs":
[{"location":"#MonteCarloX.jl-1","page":"Home","title":"MonteCarloX.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [MonteCarloX]","category":"page"},{"location":"#MonteCarloX.binary_search-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T<:Real","page":"Home","title":"MonteCarloX.binary_search","text":"binary_search(cumulated_sum::AbstractVector{T}, value::T)::Int where {T<:Real}\n\nPerfom a binary search to return the index i of an ordered array (cumulatedsum) such that cumulatedsum[i-1] < value <= cumulated_sum[i]\n\nExamples\n\njulia> MonteCarloX.binary_search([[1.,2.,3.,4.],2.5)\n3\n\njulia> MonteCarloX.binary_search([[1,2,3,4],2)\n2\n\n\n\n\n\n","category":"method"},{"location":"#MonteCarloX.log_sum-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractFloat","page":"Home","title":"MonteCarloX.log_sum","text":"log_sum(a::T,b::T)\n\nReturn result of logarithmic sum c = ln(A+B) = a + ln(1+e^b-a) where C = e^c = A+B = e^a + e^b. \n\nThis is useful for sums that involve elements that span multiple orders of magnitude, e.g., the partition sum that is required as normalization factor during reweighting.\n\nExamples\n\njulia> exp(MonteCarloX.log_sum(log(2.), log(3.)))\n5.000000000000001\n\n\n\n\n\n\n","category":"method"}]
}
