<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MonteCarloX.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MonteCarloX.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Equilibrium-Tools-1">Equilibrium Tools</a></li><li><a class="toctext" href="#Non-equilibrium-Tools-1">Non-equilibrium Tools</a></li><li><a class="toctext" href="#Helper-Modules-and-Functioms-1">Helper Modules and Functioms</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/zierenberg/MonteCarloX.jl/blob/master/docs/src/index.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="MonteCarloX.jl-Documentation-1" href="#MonteCarloX.jl-Documentation-1">MonteCarloX.jl Documentation</a></h1><ul><li><a href="#MonteCarloX.jl-Documentation-1">MonteCarloX.jl Documentation</a></li><ul><li><a href="#Equilibrium-Tools-1">Equilibrium Tools</a></li><li><a href="#Non-equilibrium-Tools-1">Non-equilibrium Tools</a></li><li><a href="#Helper-Modules-and-Functioms-1">Helper Modules and Functioms</a></li></ul></ul><h2><a class="nav-anchor" id="Equilibrium-Tools-1" href="#Equilibrium-Tools-1">Equilibrium Tools</a></h2><h3><a class="nav-anchor" id="Importance-Sampling-(Metropolis)-1" href="#Importance-Sampling-(Metropolis)-1">Importance Sampling (Metropolis)</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Metropolis.accept-Union{Tuple{N}, Tuple{Function,Tuple{Number,N},Tuple{Number,N},Random.AbstractRNG}} where N" href="#MonteCarloX.Metropolis.accept-Union{Tuple{N}, Tuple{Function,Tuple{Number,N},Tuple{Number,N},Random.AbstractRNG}} where N"><code>MonteCarloX.Metropolis.accept</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">accept(log_weight::Function, args_new::Tuple{Number, N}, args_old::Tuple{Number, N}, rng::AbstractRNG)::Bool where N</code></pre><p>Evaluate acceptance probability according to Metropolis criterium for imporance sampling of <span>$P(E) \propto e^{log\_weight(E)}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>log_weight(args)</code>: logarithmic ensemble weight function, e.g., canomical ensemble <span>$log\_weight(E) = -\beta E$</span></li><li><code>args_new</code>: arguments (can be Number or Tuple) for new (proposed) state</li><li><code>args_old</code>: arguments (can be Number or Tuple) for old            state</li><li><code>rng</code>: random number generator, e.g. MersenneTwister</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Metropolis.jl#LL11-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Metropolis.random_element-Union{Tuple{T}, Tuple{Array{T,1},Random.AbstractRNG}} where T&lt;:AbstractFloat" href="#MonteCarloX.Metropolis.random_element-Union{Tuple{T}, Tuple{Array{T,1},Random.AbstractRNG}} where T&lt;:AbstractFloat"><code>MonteCarloX.Metropolis.random_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">random_element(list_probabilities::Vector{Float64},rng::AbstractRNG)::Int</code></pre><p>Pick an index from a list of probabilities.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Metropolis.jl#LL72-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Metropolis.sweep-Union{Tuple{T}, Tuple{Any,Array{T,1},Random.AbstractRNG}} where T&lt;:AbstractFloat" href="#MonteCarloX.Metropolis.sweep-Union{Tuple{T}, Tuple{Any,Array{T,1},Random.AbstractRNG}} where T&lt;:AbstractFloat"><code>MonteCarloX.Metropolis.sweep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sweep(list_updates, list_probabilities::Vector{AbstractFloat}, rng::AbstractRNG; number_updates::Int=1)</code></pre><p>Randomly pick und run update (has to check acceptance by itself!) from <code>list_updates</code> with probability specified in <code>list_probabilities</code> and repeat this <code>number_updates</code> times.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Metropolis.jl#LL46-L52">source</a></section><h3><a class="nav-anchor" id="Reweighting-1" href="#Reweighting-1">Reweighting</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Reweighting" href="#MonteCarloX.Reweighting"><code>MonteCarloX.Reweighting</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>MonteCarloX.Reweighting</strong></p><p>Module for timeseries and histogram reweighting</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Reweighting.jl#LL1-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Reweighting.binary_search-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T&lt;:Real" href="#MonteCarloX.Reweighting.binary_search-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T&lt;:Real"><code>MonteCarloX.Reweighting.binary_search</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">binary_search(sorted::AbstractVector{T}, value::T)::Int where {T&lt;:Real}</code></pre><p>Perfom a binary search to return the index i of an sorted array such that sorted[i-1] &lt; value &lt;= sorted[i]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; MonteCarloX.binary_search([1.,2.,3.,4.],2.5)
3</code></pre><pre><code class="language-julia-repl">julia&gt; MonteCarloX.binary_search([1,2,3,4],2)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Utils.jl#LL1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Reweighting.canonical_timeseries-NTuple{4,Any}" href="#MonteCarloX.Reweighting.canonical_timeseries-NTuple{4,Any}"><code>MonteCarloX.Reweighting.canonical_timeseries</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>timeseries reweighting in canonical ensemble</p><p>methods:</p><ul><li>metropolis         (for each temperature separate)</li></ul><p>&lt;O&gt; = sum O<em>i P</em>target(E<em>i)/P</em>source(E<em>i) / sum P</em>target(E<em>i)/P</em>source(args_i)</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Reweighting.jl#LL136-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Reweighting.distribution_from_timeseries_log-Tuple{Any,Any,Any}" href="#MonteCarloX.Reweighting.distribution_from_timeseries_log-Tuple{Any,Any,Any}"><code>MonteCarloX.Reweighting.distribution_from_timeseries_log</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Estimate distribution from a list of (measured) arguments to an (n-dimensional) probability distribution</p><p>For higher dimensional distributions (e.g. P(E,M)) list_args needs to be a list of tuples</p><p>returns:</p><ul><li>Dictionary</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Reweighting.jl#LL69-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Reweighting.expectation_value_from_histogram_log-Tuple{Function,Function,Function,Dict}" href="#MonteCarloX.Reweighting.expectation_value_from_histogram_log-Tuple{Function,Function,Function,Dict}"><code>MonteCarloX.Reweighting.expectation_value_from_histogram_log</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Estimate expectation value from histogram (</p><p>Ref: Janke</p><p>Todo: rename log<em>P... to log</em>weight!!</p><p>important: hist<em>obs(args) = sum O</em>i delta(args - args_i) hists are dictionaries? can this be generalized to higher dimensions? nd histograms as dictionary?</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Reweighting.jl#LL94-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Reweighting.expectation_value_from_timeseries-NTuple{4,Any}" href="#MonteCarloX.Reweighting.expectation_value_from_timeseries-NTuple{4,Any}"><code>MonteCarloX.Reweighting.expectation_value_from_timeseries</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>timeseries reweighting </p><p>wrapper for timeseries rewighting with logarithmic distributions</p><p>#Arguments</p><ul><li></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Reweighting.jl#LL55-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Reweighting.expectation_value_from_timeseries_log-NTuple{4,Any}" href="#MonteCarloX.Reweighting.expectation_value_from_timeseries_log-NTuple{4,Any}"><code>MonteCarloX.Reweighting.expectation_value_from_timeseries_log</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>timeseries reweighting </p><p>can be used with methods:</p><ul><li>metropolis         (for each temperature separate)</li><li>parallel tempering (for each temperature separate)</li><li>multicanonical</li><li>population annealing?</li></ul><p>canonical &lt;O&gt; = sum O<em>i P</em>target(E<em>i)/P</em>source(E<em>i) / sum P</em>target(E<em>i)/P</em>source(args_i)</p><p>or in general &lt;O&gt; = sum O<em>i P</em>target(args<em>i)/P</em>source(args<em>i) / sum P</em>target(args<em>i)/P</em>source(args_i)</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Reweighting.jl#LL23-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Reweighting.log_sum-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFloat" href="#MonteCarloX.Reweighting.log_sum-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFloat"><code>MonteCarloX.Reweighting.log_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">log_sum(a::T,b::T)</code></pre><p>Return result of logarithmic sum <span>$c = \ln(A+B) = a + \ln(1+e^{|b-a|})$</span> where <span>$C = e^c = A+B = e^a + e^b$</span>. </p><p>This is useful for sums that involve elements that span multiple orders of magnitude, e.g., the partition sum that is required as normalization factor during reweighting.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; exp(MonteCarloX.log_sum(log(2.), log(3.)))
5.000000000000001
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Utils.jl#LL37-L55">source</a></section><h2><a class="nav-anchor" id="Non-equilibrium-Tools-1" href="#Non-equilibrium-Tools-1">Non-equilibrium Tools</a></h2><h3><a class="nav-anchor" id="Kintetic-Monte-Carlo-1" href="#Kintetic-Monte-Carlo-1">Kintetic Monte-Carlo</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.KineticMonteCarlo" href="#MonteCarloX.KineticMonteCarlo"><code>MonteCarloX.KineticMonteCarlo</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>MonteCarloX.KineticMonteCarlo</strong></p><p>Module that allows to implement (rejection-free) kinetic Monte Carlo algorithms in general</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/KineticMonteCarlo.jl#LL1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.KineticMonteCarlo.binary_search-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T&lt;:Real" href="#MonteCarloX.KineticMonteCarlo.binary_search-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T&lt;:Real"><code>MonteCarloX.KineticMonteCarlo.binary_search</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">binary_search(sorted::AbstractVector{T}, value::T)::Int where {T&lt;:Real}</code></pre><p>Perfom a binary search to return the index i of an sorted array such that sorted[i-1] &lt; value &lt;= sorted[i]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; MonteCarloX.binary_search([1.,2.,3.,4.],2.5)
3</code></pre><pre><code class="language-julia-repl">julia&gt; MonteCarloX.binary_search([1,2,3,4],2)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Utils.jl#LL1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.KineticMonteCarlo.log_sum-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFloat" href="#MonteCarloX.KineticMonteCarlo.log_sum-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFloat"><code>MonteCarloX.KineticMonteCarlo.log_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">log_sum(a::T,b::T)</code></pre><p>Return result of logarithmic sum <span>$c = \ln(A+B) = a + \ln(1+e^{|b-a|})$</span> where <span>$C = e^c = A+B = e^a + e^b$</span>. </p><p>This is useful for sums that involve elements that span multiple orders of magnitude, e.g., the partition sum that is required as normalization factor during reweighting.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; exp(MonteCarloX.log_sum(log(2.), log(3.)))
5.000000000000001
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Utils.jl#LL37-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.KineticMonteCarlo.next_event-Union{Tuple{T}, Tuple{Array{T,1},Random.AbstractRNG}} where T&lt;:AbstractFloat" href="#MonteCarloX.KineticMonteCarlo.next_event-Union{Tuple{T}, Tuple{Array{T,1},Random.AbstractRNG}} where T&lt;:AbstractFloat"><code>MonteCarloX.KineticMonteCarlo.next_event</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>generate events (dt,id) from a list of rates such that their occurence corresponds with their rate</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/KineticMonteCarlo.jl#LL60-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.KineticMonteCarlo.next_event-Union{Tuple{T}, Tuple{Array{T,1},T,Random.AbstractRNG}} where T&lt;:AbstractFloat" href="#MonteCarloX.KineticMonteCarlo.next_event-Union{Tuple{T}, Tuple{Array{T,1},T,Random.AbstractRNG}} where T&lt;:AbstractFloat"><code>MonteCarloX.KineticMonteCarlo.next_event</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>fast implementation of next<em>event</em>rate if sum(list_rates) is known</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/KineticMonteCarlo.jl#LL71-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.KineticMonteCarlo.next_event_id-Union{Tuple{T}, Tuple{Array{T,1},Float64,Random.AbstractRNG}} where T&lt;:AbstractFloat" href="#MonteCarloX.KineticMonteCarlo.next_event_id-Union{Tuple{T}, Tuple{Array{T,1},Float64,Random.AbstractRNG}} where T&lt;:AbstractFloat"><code>MonteCarloX.KineticMonteCarlo.next_event_id</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>next event id for list of stochastic events described by occurence rates and the sum over those</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/KineticMonteCarlo.jl#LL33-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.KineticMonteCarlo.next_event_id-Union{Tuple{T}, Tuple{Array{T,1},Random.AbstractRNG}} where T&lt;:AbstractFloat" href="#MonteCarloX.KineticMonteCarlo.next_event_id-Union{Tuple{T}, Tuple{Array{T,1},Random.AbstractRNG}} where T&lt;:AbstractFloat"><code>MonteCarloX.KineticMonteCarlo.next_event_id</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>next event id for list of stochastic events describes by cumulated rates vector</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/KineticMonteCarlo.jl#LL22-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.KineticMonteCarlo.next_event_time-Tuple{Float64,Random.AbstractRNG}" href="#MonteCarloX.KineticMonteCarlo.next_event_time-Tuple{Float64,Random.AbstractRNG}"><code>MonteCarloX.KineticMonteCarlo.next_event_time</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>next event time for Poisson process with given rate</p><p><strong>Arguments</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/KineticMonteCarlo.jl#LL12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Gillespie" href="#MonteCarloX.Gillespie"><code>MonteCarloX.Gillespie</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>MonteCarloX.Gillespie</strong></p><p>Module that allows to implement Gillespie algorithm for the statistical time trajectory of a stochastic equation Uses kinetic Monte Carlo</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Gillespie.jl#LL1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Gillespie.advance-NTuple{4,Any}" href="#MonteCarloX.Gillespie.advance-NTuple{4,Any}"><code>MonteCarloX.Gillespie.advance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Advance the system by time T </p><p>The function generates new events as long as the total time increment does not go beyond the total time T. If the next event would advance the time too far, then this event is NOT performed. The system is thus in a state that it would have after time T. </p><p>Assuming Poisson rates, the function can be called again to advance from time T because generation of events is independent. (TODO: check)</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Gillespie.jl#LL18-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Gillespie.next_event_rate-Tuple{Array,Float64,Random.AbstractRNG}" href="#MonteCarloX.Gillespie.next_event_rate-Tuple{Array,Float64,Random.AbstractRNG}"><code>MonteCarloX.Gillespie.next_event_rate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>fast implementation of next<em>event</em>rate if sum(list_rates) is known</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Gillespie.jl#LL54-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Gillespie.next_event_rate-Tuple{Array,Random.AbstractRNG}" href="#MonteCarloX.Gillespie.next_event_rate-Tuple{Array,Random.AbstractRNG}"><code>MonteCarloX.Gillespie.next_event_rate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>generate events (dt,id) from a list of rates such that their occurence corresponds with their rate</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Gillespie.jl#LL47-L49">source</a></section><h3><a class="nav-anchor" id="Inhomogeneous-Poisson-Process-1" href="#Inhomogeneous-Poisson-Process-1">Inhomogeneous Poisson Process</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.InhomogeneousPoissonProcess" href="#MonteCarloX.InhomogeneousPoissonProcess"><code>MonteCarloX.InhomogeneousPoissonProcess</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Module MonteCarloX.InhomogeneousPoissonProcess</p><p>basic functions to evaluate (a coupled set of) inhomogeneous Poisson processes with time-dependent rate function rate(t)</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/InhomogeneousPoissonProcess.jl#LL1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.InhomogeneousPoissonProcess.next_event_time-Tuple{Function,Float64,Random.AbstractRNG}" href="#MonteCarloX.InhomogeneousPoissonProcess.next_event_time-Tuple{Function,Float64,Random.AbstractRNG}"><code>MonteCarloX.InhomogeneousPoissonProcess.next_event_time</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>next<em>event</em>time(rate::Function, max_rate::Float64, rng::AbstractRNG)::Float64</p><p>Generate a new event from an inhomogeneous poisson process with rate Lambda(t). Based on (Ogata’s Modified Thinning Algorithm: Ogata,  1981,  p.25,  Algorithm  2) see also https://www.math.fsu.edu/~ychen/research/Thinning%20algorithm.pdf</p><p><strong>Arguments</strong></p><ul><li><code>rate</code>: rate(dt) has to be defined outside (e..g t-&gt; rate(t+t0,args))</li><li><code>max_rate</code>: maximal rate in near future (has to be evaluated externally)</li><li><code>rng</code>: random number generator</li></ul><p>API - output</p><ul><li>returns the next event time</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/InhomogeneousPoissonProcess.jl#LL10-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.InhomogeneousPoissonProcess.next_event_time_for_piece_wise_decreasing_rate-Tuple{Function,Random.AbstractRNG}" href="#MonteCarloX.InhomogeneousPoissonProcess.next_event_time_for_piece_wise_decreasing_rate-Tuple{Function,Random.AbstractRNG}"><code>MonteCarloX.InhomogeneousPoissonProcess.next_event_time_for_piece_wise_decreasing_rate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Generate a new event from an inhomogeneous poisson process with rate Lambda(t) under the assumption that rate(dt) is monotonically decreasing. Based on (Ogata’s Modified Thinning Algorithm: Ogata,  1981,  p.25,  Algorithm  3) see also https://www.math.fsu.edu/~ychen/research/Thinning%20algorithm.pdf</p><p><strong>Arguments</strong></p><ul><li><code>rate</code>: rate(dt) has to be defined outside (e..g t-&gt; rate(t+t0,args))</li><li><code>rng</code>: random number generator</li></ul><p>API - output</p><ul><li>returns the next event time</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/InhomogeneousPoissonProcess.jl#LL39-L52">source</a></section><h2><a class="nav-anchor" id="Helper-Modules-and-Functioms-1" href="#Helper-Modules-and-Functioms-1">Helper Modules and Functioms</a></h2><h3><a class="nav-anchor" id="Histograms-1" href="#Histograms-1">Histograms</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Histograms" href="#MonteCarloX.Histograms"><code>MonteCarloX.Histograms</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-julia">MonteCarloX.Histograms</code></pre><p>Module represents histograms/distributions as dictionaries and handles addition</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Histograms.jl#LL1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Histograms.distribution-Union{Tuple{Tx}, Tuple{Array{Tx,1},Tx,Tx}} where Tx&lt;:Real" href="#MonteCarloX.Histograms.distribution-Union{Tuple{Tx}, Tuple{Array{Tx,1},Tx,Tx}} where Tx&lt;:Real"><code>MonteCarloX.Histograms.distribution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>create a distribution (sum_args dist[args] = 1) from a list of values</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Histograms.jl#LL33-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.Histograms.histogram-Union{Tuple{Tv}, Tuple{Tx}, Tuple{Array{Tx,1},Tx,Tx}} where Tv&lt;:Real where Tx&lt;:Real" href="#MonteCarloX.Histograms.histogram-Union{Tuple{Tv}, Tuple{Tx}, Tuple{Array{Tx,1},Tx,Tx}} where Tv&lt;:Real where Tx&lt;:Real"><code>MonteCarloX.Histograms.histogram</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>create a histogram from a list of values</p><p>can this be formulated for list<em>args, dargs, args</em>ref</p></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Histograms.jl#LL10-L14">source</a></section><h3><a class="nav-anchor" id="Remaining-helper-1" href="#Remaining-helper-1">Remaining helper</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.binary_search-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T&lt;:Real" href="#MonteCarloX.binary_search-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T&lt;:Real"><code>MonteCarloX.binary_search</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">binary_search(sorted::AbstractVector{T}, value::T)::Int where {T&lt;:Real}</code></pre><p>Perfom a binary search to return the index i of an sorted array such that sorted[i-1] &lt; value &lt;= sorted[i]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; MonteCarloX.binary_search([1.,2.,3.,4.],2.5)
3</code></pre><pre><code class="language-julia-repl">julia&gt; MonteCarloX.binary_search([1,2,3,4],2)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Utils.jl#LL1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloX.log_sum-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFloat" href="#MonteCarloX.log_sum-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFloat"><code>MonteCarloX.log_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">log_sum(a::T,b::T)</code></pre><p>Return result of logarithmic sum <span>$c = \ln(A+B) = a + \ln(1+e^{|b-a|})$</span> where <span>$C = e^c = A+B = e^a + e^b$</span>. </p><p>This is useful for sums that involve elements that span multiple orders of magnitude, e.g., the partition sum that is required as normalization factor during reweighting.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; exp(MonteCarloX.log_sum(log(2.), log(3.)))
5.000000000000001
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/zierenberg/MonteCarloX.jl/blob/1300e47d40ace0105c975c97eec01b4541b02c82/src/Utils.jl#LL37-L55">source</a></section><footer><hr/></footer></article></body></html>
